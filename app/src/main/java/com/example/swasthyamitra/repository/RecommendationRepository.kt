package com.example.swasthyamitra.repository

import com.example.swasthyamitra.models.Recommendation
import com.example.swasthyamitra.models.SuggestedFood
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.Query
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.tasks.await

/**
 * Repository for managing meal recommendations from Firestore.
 * Recommendations are generated by Cloud Functions and stored in the 'recommendations' collection.
 */
class RecommendationRepository {
    
    private val db = FirebaseFirestore.getInstance("renu") // Using RENU database instance
    private val auth = FirebaseAuth.getInstance()
    
    private val recommendationsCollection = db.collection("recommendations")
    
    /**
     * Observes pending recommendations for the current user in real-time.
     * Returns a Flow that emits the latest list of recommendations whenever data changes.
     */
    fun observeRecommendations(): Flow<List<Recommendation>> = callbackFlow {
        val userId = auth.currentUser?.uid ?: run {
            trySend(emptyList())
            close()
            return@callbackFlow
        }
        
        val listenerRegistration = recommendationsCollection
            .whereEqualTo("userId", userId)
            .whereEqualTo("status", "Pending")
            .orderBy("createdAt", Query.Direction.DESCENDING)
            .limit(10)
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    close(error)
                    return@addSnapshotListener
                }
                
                val recommendations = snapshot?.documents?.mapNotNull { doc ->
                    try {
                        val data = doc.data ?: return@mapNotNull null
                        
                        // Parse suggestedFoods array
                        val suggestedFoodsRaw = data["suggestedFoods"] as? List<*> ?: emptyList<Any>()
                        val suggestedFoods = suggestedFoodsRaw.mapNotNull { foodMap ->
                            (foodMap as? Map<*, *>)?.let { map ->
                                SuggestedFood(
                                    name = map["name"] as? String ?: "",
                                    calories = (map["calories"] as? Number)?.toInt() ?: 0,
                                    protein = (map["protein"] as? Number)?.toDouble() ?: 0.0,
                                    carbs = (map["carbs"] as? Number)?.toDouble() ?: 0.0,
                                    fat = (map["fat"] as? Number)?.toDouble() ?: 0.0,
                                    servingSize = map["servingSize"] as? String ?: "1 serving",
                                    reason = map["reason"] as? String ?: ""
                                )
                            }
                        }
                        
                        Recommendation(
                            documentId = doc.id,
                            userId = data["userId"] as? String ?: "",
                            type = data["type"] as? String ?: "",
                            mealTime = data["mealTime"] as? String ?: "",
                            suggestedFoods = suggestedFoods,
                            remainingCalories = (data["remainingCalories"] as? Number)?.toInt() ?: 0,
                            message = data["message"] as? String ?: "",
                            createdAt = (data["createdAt"] as? com.google.firebase.Timestamp)?.seconds ?: 0L,
                            status = data["status"] as? String ?: "Pending"
                        )
                    } catch (e: Exception) {
                        null
                    }
                } ?: emptyList()
                
                trySend(recommendations)
            }
        
        awaitClose { listenerRegistration.remove() }
    }
    
    /**
     * Updates the status of a recommendation (e.g., to "Dismissed" or "Accepted").
     * This feedback is used by the system to improve future recommendations.
     */
    suspend fun updateRecommendationStatus(documentId: String, newStatus: String): Boolean {
        return try {
            recommendationsCollection.document(documentId)
                .update("status", newStatus)
                .await()
            true
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }
    
    /**
     * Marks a recommendation as accepted and logs the selected food.
     */
    suspend fun acceptRecommendation(documentId: String): Boolean {
        return updateRecommendationStatus(documentId, "Accepted")
    }
    
    /**
     * Marks a recommendation as dismissed (user saw it but chose not to follow it).
     */
    suspend fun dismissRecommendation(documentId: String): Boolean {
        return updateRecommendationStatus(documentId, "Dismissed")
    }
    
    /**
     * Fetches recommendations once (non-real-time) for the current user.
     */
    suspend fun getRecommendations(): List<Recommendation> {
        val userId = auth.currentUser?.uid ?: return emptyList()
        
        return try {
            val snapshot = recommendationsCollection
                .whereEqualTo("userId", userId)
                .whereEqualTo("status", "Pending")
                .orderBy("createdAt", Query.Direction.DESCENDING)
                .limit(10)
                .get()
                .await()
            
            snapshot.documents.mapNotNull { doc ->
                try {
                    val data = doc.data ?: return@mapNotNull null
                    
                    val suggestedFoodsRaw = data["suggestedFoods"] as? List<*> ?: emptyList<Any>()
                    val suggestedFoods = suggestedFoodsRaw.mapNotNull { foodMap ->
                        (foodMap as? Map<*, *>)?.let { map ->
                            SuggestedFood(
                                name = map["name"] as? String ?: "",
                                calories = (map["calories"] as? Number)?.toInt() ?: 0,
                                protein = (map["protein"] as? Number)?.toDouble() ?: 0.0,
                                carbs = (map["carbs"] as? Number)?.toDouble() ?: 0.0,
                                fat = (map["fat"] as? Number)?.toDouble() ?: 0.0,
                                servingSize = map["servingSize"] as? String ?: "1 serving",
                                reason = map["reason"] as? String ?: ""
                            )
                        }
                    }
                    
                    Recommendation(
                        documentId = doc.id,
                        userId = data["userId"] as? String ?: "",
                        type = data["type"] as? String ?: "",
                        mealTime = data["mealTime"] as? String ?: "",
                        suggestedFoods = suggestedFoods,
                        remainingCalories = (data["remainingCalories"] as? Number)?.toInt() ?: 0,
                        message = data["message"] as? String ?: "",
                        createdAt = (data["createdAt"] as? com.google.firebase.Timestamp)?.seconds ?: 0L,
                        status = data["status"] as? String ?: "Pending"
                    )
                } catch (e: Exception) {
                    null
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
            emptyList()
        }
    }
}
