# Firebase Schema - AI Smart Diet Feature

## Collections & Document Structure

### 1. user_preferences/{userId}
Stores user's food preferences and history

```json
{
  "dislikedFoods": [
    "Paneer Butter Masala",
    "Chole Bhature",
    "Vada Pav"
  ],
  "favoriteFoods": [
    "Idli Sambar",
    "Khichdi",
    "Fruit Salad"
  ],
  "lastUpdated": Timestamp
}
```

**Security Rules:**
- Only owner can read/write
- Document ID = userId

**Operations:**
- CREATE: When first meal is skipped or eaten
- UPDATE: Every time user skips/eats a meal
- READ: When generating new meals (to fetch disliked foods)

---

### 2. meal_feedback/{feedbackId}
Tracks all user interactions with meal suggestions

```json
{
  "userId": "user123",
  "mealName": "Masala Dosa",
  "mealType": "Breakfast",
  "action": "Ate",  // "Ate" | "Skipped" | "New"
  "timestamp": 1739174400000,
  "date": "2026-02-10",
  "reason": null  // Optional
}
```

**Security Rules:**
- Authenticated users can read
- Only owner can create/update/delete

**Use Cases:**
- Analytics on meal preferences
- Track user engagement
- Identify popular meals
- Refine AI recommendations

---

### 3. foodLogs/{logId}
Stores meals that user has eaten (from "Ate" button)

```json
{
  "userId": "user123",
  "foodName": "Masala Dosa",
  "calories": 350,
  "protein": 12.5,
  "carbs": 0.0,
  "fat": 0.0,
  "mealType": "Breakfast",
  "timestamp": 1739174400000,
  "date": "2026-02-10",
  "servingSize": "1 serving",
  "barcode": null,
  "photoUrl": null
}
```

**Security Rules:**
- Authenticated users can read (for queries)
- Only owner can create
- Only owner can update/delete own logs

**Retention:**
- Minimum 7 days (configurable)
- Used for meal history analysis
- Displayed in Food Log Activity

---

### 4. ai_generated_plans/{planId}
Stores complete daily meal plans generated by AI

```json
{
  "userId": "user123",
  "generatedAt": 1739174400000,
  "date": "2026-02-10",
  "breakfast": {
    "item": "Poha with Tea",
    "calories": 250,
    "protein": "8g",
    "reason": "Light, easy to digest morning meal"
  },
  "lunch": {
    "item": "Rajma Chawal",
    "calories": 450,
    "protein": "15g",
    "reason": "High protein, balanced meal"
  },
  "snack": {
    "item": "Fruit Chaat",
    "calories": 150,
    "protein": "3g",
    "reason": "Natural sugars for energy"
  },
  "dinner": {
    "item": "Roti with Dal Tadka",
    "calories": 350,
    "protein": "12g",
    "reason": "Light dinner for good sleep"
  },
  "postWorkout": {
    "item": "Banana Protein Shake",
    "calories": 200,
    "protein": "20g",
    "reason": "Muscle recovery"
  },
  "dailyTip": "Stay hydrated! Drink at least 8 glasses of water today.",
  "totalCalories": 1400,
  "status": "Active"
}
```

**Security Rules:**
- Only owner can read
- System creates (not user-editable)

**Use Cases:**
- Historical plan tracking
- Pattern analysis
- Plan regeneration reference

---

## Data Flow Diagrams

### Flow 1: User Taps "Ate" Button
```
[User taps "Ate"]
       ‚Üì
[handleMealAction(mealType, meal, "Ate")]
       ‚Üì
[trackFeedback(userId, mealName, mealType, "Ate")]
       ‚Üì
[meal_feedback collection] ‚Üê Save feedback
       ‚Üì
[logMealToFoodLog(meal, mealType)]
       ‚Üì
[foodLogs collection] ‚Üê Save full meal details
       ‚Üì
[updateUserPreferences(userId, mealName, isDisliked=false)]
       ‚Üì
[user_preferences.favoriteFoods] ‚Üê Add to favorites
       ‚Üì
[Show toast: "‚úÖ Logged: {meal}"]
```

### Flow 2: User Taps "Skip" Button
```
[User taps "Skip"]
       ‚Üì
[handleMealAction(mealType, meal, "Skipped")]
       ‚Üì
[trackFeedback(userId, mealName, mealType, "Skipped")]
       ‚Üì
[meal_feedback collection] ‚Üê Save feedback
       ‚Üì
[addToDislikedFoods(userId, mealName)]
       ‚Üì
[user_preferences.dislikedFoods] ‚Üê Add to disliked
       ‚Üì
[regenerateMeal(mealType, currentItem)]
       ‚Üì
[Fetch user_preferences.dislikedFoods] ‚Üê Get all disliked
       ‚Üì
[Generate new meal via Gemini AI]
   (Exclude: current + all disliked foods)
       ‚Üì
[Update UI with new meal]
       ‚Üì
[Show toast: "‚è≠Ô∏è Skipped: {meal}. Generating new..."]
```

### Flow 3: User Taps "New" Button
```
[User taps "New"]
       ‚Üì
[regenerateMeal(mealType, currentItem)]
       ‚Üì
[Fetch user_preferences.dislikedFoods] ‚Üê Get all disliked
       ‚Üì
[Combine: currentItem + dislikedFoods = allExclusions]
       ‚Üì
[Generate new meal via Gemini AI]
   (Exclude: all items in allExclusions)
       ‚Üì
[trackFeedback(userId, newMeal, mealType, "New")]
       ‚Üì
[meal_feedback collection] ‚Üê Save feedback
       ‚Üì
[Update UI with new meal]
       ‚Üì
[Show toast: "üîÅ New {mealType}: {newMeal}"]
```

---

## Query Examples

### Get User's Disliked Foods
```kotlin
val dislikedFoods = firestore
    .collection("user_preferences")
    .document(userId)
    .get()
    .await()
    .get("dislikedFoods") as? List<String> ?: emptyList()
```

### Get Recent Food Logs (7 days)
```kotlin
val sevenDaysAgo = System.currentTimeMillis() - (7 * 24 * 60 * 60 * 1000)
val foodLogs = firestore
    .collection("foodLogs")
    .whereEqualTo("userId", userId)
    .whereGreaterThan("timestamp", sevenDaysAgo)
    .orderBy("timestamp", Query.Direction.DESCENDING)
    .get()
    .await()
```

### Get All Meal Feedback for Analysis
```kotlin
val feedback = firestore
    .collection("meal_feedback")
    .whereEqualTo("userId", userId)
    .whereEqualTo("action", "Skipped")
    .get()
    .await()
```

### Get Today's Eaten Meals
```kotlin
val dateFormat = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
val today = dateFormat.format(Date())

val todaysMeals = firestore
    .collection("foodLogs")
    .whereEqualTo("userId", userId)
    .whereEqualTo("date", today)
    .get()
    .await()
```

---

## Indexes Required

### foodLogs Collection
```json
{
  "collectionGroup": "foodLogs",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "userId", "order": "ASCENDING" },
    { "fieldPath": "timestamp", "order": "DESCENDING" }
  ]
}
```

### meal_feedback Collection
```json
{
  "collectionGroup": "meal_feedback",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "userId", "order": "ASCENDING" },
    { "fieldPath": "date", "order": "DESCENDING" }
  ]
}
```

---

## Storage Estimates

### Per User (Monthly):
- **user_preferences**: 1 document (~5KB)
  - Average 20-30 disliked foods
  - Average 10-15 favorite foods

- **meal_feedback**: ~120 documents (~15KB)
  - 4 meals/day √ó 30 days = 120 entries
  - Each entry ~128 bytes

- **foodLogs**: ~120 documents (~30KB)
  - 4 meals/day √ó 30 days = 120 entries
  - Each entry ~256 bytes

- **ai_generated_plans**: ~30 documents (~90KB)
  - 1 plan/day √ó 30 days
  - Each plan ~3KB

**Total per user/month**: ~140KB

### For 1000 Users:
- Total storage: ~140MB/month
- Firestore reads: ~3000-5000/day
- Firestore writes: ~1000-2000/day

---

## Cleanup Strategies

### Food Logs (Keep 30 days)
```kotlin
// Run weekly via Cloud Function
val thirtyDaysAgo = System.currentTimeMillis() - (30 * 24 * 60 * 60 * 1000)
firestore.collection("foodLogs")
    .whereLessThan("timestamp", thirtyDaysAgo)
    .get()
    .await()
    .documents
    .forEach { it.reference.delete() }
```

### Meal Feedback (Keep 90 days)
```kotlin
val ninetyDaysAgo = System.currentTimeMillis() - (90 * 24 * 60 * 60 * 1000)
firestore.collection("meal_feedback")
    .whereLessThan("timestamp", ninetyDaysAgo)
    .get()
    .await()
    .documents
    .forEach { it.reference.delete() }
```

### AI Generated Plans (Keep 60 days)
```kotlin
val sixtyDaysAgo = System.currentTimeMillis() - (60 * 24 * 60 * 60 * 1000)
firestore.collection("ai_generated_plans")
    .whereLessThan("generatedAt", sixtyDaysAgo)
    .get()
    .await()
    .documents
    .forEach { it.reference.delete() }
```

---

## Backup Strategy

### Daily Backups
- Enable Firestore automatic backups
- Retention: 30 days
- Backup location: Same region as Firestore

### Export Schedule
```bash
# Weekly full export
gcloud firestore export gs://backup-bucket/weekly/$(date +%Y%m%d)

# Daily incremental
gcloud firestore export \
  --collection-ids=foodLogs,meal_feedback,user_preferences \
  gs://backup-bucket/daily/$(date +%Y%m%d)
```

---

## Security Best Practices

1. **Always validate userId matches auth.uid**
2. **Use timestamps for ordering and cleanup**
3. **Sanitize user input before storing**
4. **Limit array sizes (dislikedFoods max 100)**
5. **Use batch writes for multiple updates**
6. **Enable audit logging for compliance**

---

## Monitoring Queries

### Check Disliked Foods Growth
```kotlin
val avgDislikedCount = firestore
    .collection("user_preferences")
    .get()
    .await()
    .documents
    .mapNotNull { (it.get("dislikedFoods") as? List<*>)?.size }
    .average()
```

### Most Skipped Meals
```kotlin
val topSkipped = firestore
    .collection("meal_feedback")
    .whereEqualTo("action", "Skipped")
    .get()
    .await()
    .documents
    .groupingBy { it.getString("mealName") }
    .eachCount()
    .entries
    .sortedByDescending { it.value }
    .take(10)
```

### Most Popular Meals
```kotlin
val topEaten = firestore
    .collection("foodLogs")
    .get()
    .await()
    .documents
    .groupingBy { it.getString("foodName") }
    .eachCount()
    .entries
    .sortedByDescending { it.value }
    .take(10)
```

---

**Last Updated**: February 10, 2026  
**Version**: 1.0  
**Status**: Production Ready

